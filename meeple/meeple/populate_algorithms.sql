--
-- PostgreSQL database dump
--

-- Dumped from database version 14.17 (Ubuntu 14.17-0ubuntu0.22.04.1)
-- Dumped by pg_dump version 14.17 (Ubuntu 14.17-0ubuntu0.22.04.1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: evaluation_algorithm; Type: TABLE; Schema: public; Owner: alumnodb
--

CREATE TABLE public.evaluation_algorithm (
    id bigint NOT NULL,
    name character varying(100) NOT NULL,
    version character varying(15) NOT NULL,
    description text NOT NULL,
    code text,
    type character varying(20) NOT NULL
);


ALTER TABLE public.evaluation_algorithm OWNER TO alumnodb;

--
-- Name: evaluation_algorithm_id_seq; Type: SEQUENCE; Schema: public; Owner: alumnodb
--

ALTER TABLE public.evaluation_algorithm ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.evaluation_algorithm_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Data for Name: evaluation_algorithm; Type: TABLE DATA; Schema: public; Owner: alumnodb
--

COPY public.evaluation_algorithm (id, name, version, description, code, type) FROM stdin;
1	Random Algorithm	1	Función que recomienda juegos de mesa de forma aleatoria.	def recommend(user, responses, number_sections=1):\n    """\n    Función que recomienda juegos de mesa de forma aleatoria.\n    \n    Args:\n        user (User): El usuario autenticado.\n        responses (list): Las preferencias o categorías que el usuario tiene para los juegos.\n        number_sections (int, optional): Número de juegos a recomendar. Default es 1.\n\n    Returns:\n        list: Lista de juegos recomendados.\n    """\n    # Construir la consulta SQL usando las condiciones dinámicas.\n    sql = """\n    SELECT id\n    FROM zacatrus_games\n    ORDER BY RAND()\n    LIMIT %s\n    """\n    \n    # Ejecutar la consulta y obtener los resultados\n    games = db_query(sql, [number_sections])\n    \n    recommended_games = []\n\n    for game in games:\n        recommended_games.append(game[0])\n    \n    return recommended_games\n	random
2	Popular Algorithm	1	Función que recomienda los juegos de mesa más populares.	def recommend(user, responses, number_sections=1):\n    """\n    Función que recomienda los juegos de mesa más populares.\n    \n    Args:\n        user (User): El usuario autenticado.\n        responses (list): Las preferencias o categorías que el usuario tiene para los juegos.\n        number_sections (int, optional): Número de juegos a recomendar. Default es 1.\n\n    Returns:\n        list: Lista de juegos recomendados.\n    """\n    # Construir la consulta SQL usando las condiciones dinámicas.\n    sql = """\n    SELECT gameId, AVG(rating) as average_rating\n    FROM zacatrus_ratings\n    GROUP BY gameId\n    ORDER BY average_rating DESC\n    LIMIT %s\n    """\n    \n    # Ejecutar la consulta y obtener los resultados\n    games = db_query(sql, [number_sections])\n    \n    recommended_games = []\n\n    for game in games:\n        recommended_games.append(game[0])\n    \n    return recommended_games\n	random
3	Contexts Algorithm	1	Algoritmo de recomendación que devuelve el id de x juegos basado en los contextos preferidas del usuario.	def recommend(user, responses, number_sections = 1):\n    """\n    Algoritmo de recomendación que devuelve el id de x juegos basado en los contextos preferidas del usuario.\n\n    :param user: Objeto del usuario (puede no ser necesario en este caso).\n    :param responses: Diccionario con las contextos preferidas, por ejemplo:\n                      {"contexts": ['time:short', 'social:children', 'mood:strategic']}\n    :return: El id del juego recomendado, o None si no se encuentra coincidencia.\n    """\n    # Extraer la lista de contextos desde el diccionario\n    contexts = responses.get("contexts", [])\n\n    # Caso 1: Si no hay contextos, seleccionar un juego aleatorio\n    if not contexts:\n        sql = """\n        SELECT id \n        FROM zacatrus_games\n        ORDER BY RANDOM()\n        LIMIT 1;\n        """\n        result = db_query(sql, [])\n        return result[0][0] if result else None\n\n    # Construir condiciones dinámicas para la consulta SQL.\n    # Por cada contexto, creamos una condición: "contexts LIKE %s"\n    context_conditions = " OR ".join(["contexts LIKE %s" for _ in contexts])\n    # Y definimos los parámetros: para cada contexto, se envuelve en %...%\n    params = ["%" + ctx + "%" for ctx in contexts]\n\n    # Construir la consulta SQL usando las condiciones dinámicas.\n    sql = f"""\n    SELECT zg.id, zg.name, GROUP_CONCAT(DISTINCT zgc.name ORDER BY zgc.name ASC) AS contexts\n    FROM (\n        SELECT id, name, url\n        FROM zacatrus_games\n        LIMIT 10\n    ) zg\n    LEFT JOIN (\n        SELECT DISTINCT gameid, name\n        FROM zacatrus_game_contexts\n    ) zgc ON zg.id = zgc.gameid\n    GROUP BY zg.id, zg.name\n    HAVING {context_conditions};\n    """\n\n    # Ejecutar la consulta y obtener los resultados\n    result = db_query(sql, params)\n    # print(result)  # Para debug; quitar en producción\n\n    # Filtrar los juegos que coincidan con alguna de las contextos del usuario\n    matching_games = []\n    for row in result:\n        game_id, game_name, game_contexts = row\n        if not game_contexts:\n            continue  # Si no hay contextos, saltar este juego\n        # Separar las contextos concatenadas y limpiar espacios\n        game_contexts_list = [cat.strip() for cat in game_contexts.split(',')]\n        \n        # Verificar si alguna de las contextos del juego coincide exactamente con alguna contexto preferida\n        match_found = False\n        for cat in game_contexts_list:\n            for pref in contexts:\n                if cat == pref:\n                    match_found = True\n                    break\n            if match_found:\n                break\n\n        if match_found:\n            matching_games.append(game_id)\n\n    # Si hay juegos coincidentes, seleccionar uno al azar y devolver su ID\n    if matching_games:\n        if len(matching_games) >= number_sections:\n            return random.sample(matching_games, number_sections)\n        else:\n            return random.choices(matching_games, k=number_sections)\n    else:\n        return None  # Si no hay coincidencias, se devuelve None\n	content
4	Categories Algorithm	1	Algoritmo de recomendación que devuelve el id de x juegos basado en las categorías preferidas del usuario.	def recommend(user, responses, number_sections = 1):\n    """\n    Algoritmo de recomendación que devuelve el id de x juegos basado en las categorías preferidas del usuario.\n\n    :param user: Objeto del usuario (puede no ser necesario en este caso).\n    :param responses: Diccionario con las categorías preferidas, por ejemplo:\n                      {"categories": ['Economic', 'Negotiation', 'Political']}\n    :return: El id del juego recomendado, o None si no se encuentra coincidencia.\n    """\n    # Extraer la lista de categorías desde el diccionario\n    categories = responses.get("categories", [])\n\n    # Caso 1: Si no hay categorías, seleccionar un juego aleatorio\n    if not categories:\n        sql = """\n        SELECT id \n        FROM zacatrus_games\n        ORDER BY RANDOM()\n        LIMIT 1;\n        """\n        result = db_query(sql, [])\n        return result[0][0] if result else None\n\n    # Construir condiciones dinámicas para la consulta SQL.\n    # Por cada categoría, creamos una condición: "categories LIKE %s"\n    category_conditions = " OR ".join(["categories LIKE %s" for _ in categories])\n    # Y definimos los parámetros: para cada categoría, se envuelve en %...%\n    params = ["%" + cat + "%" for cat in categories]\n\n    # Construir la consulta SQL usando las condiciones dinámicas.\n    sql = f"""\n    SELECT zg.id, zg.name, GROUP_CONCAT(DISTINCT zgc.name ORDER BY zgc.name ASC) AS categories\n    FROM (\n        SELECT id, name, url\n        FROM zacatrus_games\n        LIMIT 10\n    ) zg\n    LEFT JOIN (\n        SELECT DISTINCT gameid, name\n        FROM zacatrus_game_categories\n    ) zgc ON zg.id = zgc.gameid\n    GROUP BY zg.id, zg.name\n    HAVING {category_conditions};\n    """\n\n    # Ejecutar la consulta y obtener los resultados\n    result = db_query(sql, params)\n    # print(result)  # Para debug; quitar en producción\n\n    # Filtrar los juegos que coincidan con alguna de las categorías del usuario\n    matching_games = []\n    for row in result:\n        game_id, game_name, game_categories = row\n        if not game_categories:\n            continue  # Si no hay categorías, saltar este juego\n        # Separar las categorías concatenadas y limpiar espacios\n        game_categories_list = [cat.strip() for cat in game_categories.split(',')]\n        \n        # Verificar si alguna de las categorías del juego coincide exactamente con alguna categoría preferida\n        match_found = False\n        for cat in game_categories_list:\n            for pref in categories:\n                if cat == pref:\n                    match_found = True\n                    break\n            if match_found:\n                break\n\n        if match_found:\n            matching_games.append(game_id)\n\n    # Si hay juegos coincidentes, seleccionar uno al azar y devolver su ID\n    if matching_games:\n        if len(matching_games) >= number_sections:\n            return random.sample(matching_games, number_sections)\n        else:\n            return random.choices(matching_games, k=number_sections)\n    else:\n        return None  # Si no hay coincidencias, se devuelve None\n	content
\.


--
-- Name: evaluation_algorithm_id_seq; Type: SEQUENCE SET; Schema: public; Owner: alumnodb
--

SELECT pg_catalog.setval('public.evaluation_algorithm_id_seq', 1, false);


--
-- Name: evaluation_algorithm evaluation_algorithm_pkey; Type: CONSTRAINT; Schema: public; Owner: alumnodb
--

ALTER TABLE ONLY public.evaluation_algorithm
    ADD CONSTRAINT evaluation_algorithm_pkey PRIMARY KEY (id);


--
-- PostgreSQL database dump complete
--

